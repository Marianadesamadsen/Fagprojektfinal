function [X] = EulerM(f,tspan,x0,u,d,p)




% Number of steps to approximate each the control step
N = numel(tspan) - 1;

% Length of the vector
nx = numel(x0);

% Allocating memory for Outputs
T = zeros(N+1, 1);
X = zeros(N+1, nx);

% Storing initial condition
T(1) = tspan(1);
X(1,:) = x0;

% Step size in the approximation (Explicit Euler step)
h = (tspan(end)-tspan(1))/N;

lambda = 1.5;
mu = 0; 

for k=1:N

    % Calculating fk (finding derivative with MVP model)
    fk = feval(f, tk, xk, u, d, p);

    % Calculating xk+1 (Explicit Euler step)
    xkp1 = xk + h*fk;

    % Storing it in the matrix
    X(k+1,:) = xkp1;

    % Updating the xk
    xk=xkp1;

    % Updating to tkp1
    tkp1 = tspan(k+1);

    % Storing in vector
    T(k+1) = tkp1;

dt = T/N;

R = 4; 
Dt = R*dt; 
L = N/R; % L EM steps of size Dt = R*dt
Xem = zeros(1,L); % preallocate for efficiency
Xtemp = x0;

for j = 1:L
    
Winc = sum(dW(R*(j-1)+1:R*j));
Xtemp = Xtemp + Dt*lambda*Xtemp + mu*Xtemp*Winc;
Xem(j) = Xtemp;

end

X=Xem;
    
    
    
end



end


